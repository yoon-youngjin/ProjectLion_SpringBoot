# 동기 vs 비동기 & Blocking vs Non Blocking

## 동기 vs 비동기 

- 동기(Synchronous): 일반적으로 작업자(Thread)가 한 명일 경우 성립되는 방식이며 작업자는 작업의 결과에 관심이 있는 상태다. 
  - 작업자 N명이 작업을 서로 분담해서 진행하는 순간 원칙적으로 동기는 깨지게 된다.
  - 작업자1과 작업자2는 서로 각자 자신의 일을 동시에 진행한다. 또한 각자의 결과에 관심이 없다.
- 비동기(Asynchronous): 일반적으로 비동기는 N명의 작업자들 관계에서 성립되는 방식이라 할 수 있다.
  - Fire and Forget 이라는 용어가 있는데 이는 비동기 프로그래밍 용어로써 작업을 시작하고 그 결과에 대해 더 이상 관심을 갖지 않고 진행하는 것을 의미한다.
  - 비동기는 작업자간의 관계를 이해해야 한다. 
  - 작업자 1은 작업자 2의 결과에 관심이 없으며 기다리지 않는다. 작업자 2가 작업을 완료하면 작업자 1에게 작업 종료를 알린다. 
  - 즉, 작업이 순차적이지 않으며 각각 동시에 자신의 업무를 처리한다.
  - 참고로 작업 결과에 관심이 없는 주체는 작업을 맡긴쪽(작업자 1)이다.

![image](https://github.com/yoon-youngjin/spring-study/assets/83503188/98ad83c2-4947-441a-a456-3d89d65ffc31)

**작업을 처리하는 작업자가 두 명인 비동기 상황에서 동기식 처리가 가능한가?**

- 한 작업자가 다른 작업자의 작업 결과에 관심이 있고 확인 할 경우 비동기 안에서 동기식 처리가 될 수 있다.
- 작업자 1은 다른 일을 볼 수 있지만 다른 일을 보면서 작업 결과를 확인하는 순간에는 다른 작업을 할 수 없다.

![image](https://github.com/yoon-youngjin/spring-study/assets/83503188/1fcd2e64-3ab8-4b4d-b66b-dc0c45d9f09b)

## 블로킹 vs 논블로킹

- 블로킹(Blocking): 동기 작업에서 나타나는 현상으로 작업이 완료될 때까지 실행 흐름을 멈추고 대기하는 상태를 의미힌다.
  - 일반적으로 블로킹은 작업자가 한 명인 동기에서 대부분 발생한다.
- 논블로킹(Non Blocking): 비동기 작업에서 나타나는 현상으로 블로킹 되지 않고 실행 흐름이 지속되는 특성을 나타낸다.
  - 일반적으로 논블로킹은 N명의 작업자들 관계에서 이루어지는 비동기에서 발생한다.
  - 작업자2가 작업자1에게 작업 종료를 알리는 방식을 Callback 방식이라 한다.
![image](https://github.com/yoon-youngjin/spring-study/assets/83503188/e999c993-11ea-4fde-bfcd-ea43e6657f35)

**작업을 처리하는 작업자가 두 명인 비동기 상황에서 블로킹이 발생할 수 있는가?**

- 비동기 안에서 동기식 처리와 함께 대기로 인한 블로킹이 발생할 수 있다.
- 작업자1이 작업자2에게 작업을 맡기고 다른 일을 하지 않고 지속적으로 작업자2의 작업 완료를 기다리고 있는 Blocking 상태가 발생할 수 있다. 

![image](https://github.com/yoon-youngjin/spring-study/assets/83503188/96fe1fd6-7715-4894-8c43-537bde89f45d)

## 함수 관점에서 동기 & 비동기

- 함수를 호출한자(Caller)와 호출된 함수를 수행하는 주체(Callee)가 동일 스레드이면 동기, 서로 다른 스레드이면 비동기 관계가 형성 된다고 할 수 있다.

![image](https://github.com/yoon-youngjin/spring-study/assets/83503188/3757e05e-6574-4813-b4ed-f9d8e041841c)

- 함수를 호출한자(Caller)와 호출된 함수의 작업 결과에 대해 관심을 가지고 있으면 동기, 없으면 비동기라 할 수 있다.

![image](https://github.com/yoon-youngjin/spring-study/assets/83503188/597fe390-2481-47a2-8125-e6a2382cb524)

**동기와 비동기는 작업을 실행하는 작업자들 즉, 스레드 간 구성에 관한 문제이다.**

## 함수 관점에서 블로킹 & 논블로킹

- 함수를 호출한자와 호출된 함수를 수행하는 주체가 동일 스레드이면 블로킹, 서로 다른 스레드이면 논블로킹이 발생한다고 볼 수 있다.

![image](https://github.com/yoon-youngjin/spring-study/assets/83503188/1eb13e36-db56-4ccc-b0a4-d6bb9faceae9)

- 함수를 호출한자와 호출된 함수를 수행하는 주체가 순차적으로 작업을 진행하면 블로킹, 동시적으로 진행하면 논블로킹이라 할 수 있다.

![image](https://github.com/yoon-youngjin/spring-study/assets/83503188/16e5b66d-07f5-4dad-a5bc-ad90b48a63f8)

**블로킹과 논블로킹은 작업자의 작업 즉, 스레드 간 행위에 관한 문제이다.**

## 동기 & 블로킹

- 일반적으로 단일 스레드에서 실행되는 경우 동기 & 블로킹 관계를 가질 수 밖에 없다.

![image](https://github.com/yoon-youngjin/spring-study/assets/83503188/126c3c81-bd84-4bed-b5f5-0bbf1d8b7a2b)

## 동기 & 논블로킹

- 동기: 스레드 간 관계는 비동기로 시작했지만 한 스레드가 다른 스레드의 작업 결과에 관심을 가짐으로써 부분적으로 동기 처리가 될 수 있다.
- 논블로킹: 스레드 관계는 비동기이고 스레드 마다 독립적으로 작업을 계속 실행해 나가기 때문에 결과를 기다리거나 대기하는 상황이 발생하지 않는다.

![image](https://github.com/yoon-youngjin/spring-study/assets/83503188/ea56f796-7a4c-4ea8-a8d9-228c02ea42fd)

위 로직은 비동기 & 논블로킹으로 실행됐지만 일부분이 동기적인 처리가 있으므로 동기 & 논블로킹이라고 해석된 것이다.

## 비동기 & 블로킹

- 비동기: 작업을 호출하고 작업을 처리하는 스레드가 서로 다르기 때문에 각각 다른 스택 공간에서 독립적으로 작업을 수행하는 관계를 가진다.
- 블로킹: 비동기 작업을 수행하다가 외부 리소스의 응답을 기다려야 할 때 블로킹이 발생할 수 있다.

![image](https://github.com/yoon-youngjin/spring-study/assets/83503188/2ba5697c-867f-4bf3-917c-9febd594f2d1)

## 비동기 & 논블로킹

- 비동기: 작업을 호출하고 작업을 처리하는 주체가 서로 다르고 각각 다른 스택 공간에서 독립적으로 작업을 수행하며 다른 스레드의 실행결과나 응답에 관심이 없다.
- 논블로킹: 스레드 관계는 비동기이고 스레드 마다 독립적으로 작업을 계속 실행해 나가기 때문에 블로킹 현상이 발생하지 않는다.

![image](https://github.com/yoon-youngjin/spring-study/assets/83503188/55daf1a5-10e2-4055-9702-7002dc1eddc1)
