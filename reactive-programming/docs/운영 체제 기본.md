# 운영 체제 기본

## Process & Thread

### Process

- 운영체제에 의해 파일 시스템에 설치되어 있는 파일을 프로그램이라 칭한다.
- 프로세스는 프로그램의 실제 실행을 의미하며 프로그램 파일을 실행함으로써 프로그램 데이터들이 메모리에 올라와 **CPU를 할당받고 명령을 수행하고 있는 상태이다**
  - 조금 더 상세히는 프로세스는 운영체제로부터 메모리 자원을 할당받는것이고 실제 CPU를 할당받아서 코드를 실행시키는 주체는 thread이다.
  - JVM이 하나의 프로세스이고 JVM이 실행될때 자동으로 main thread가 생성되어 실행시킨다.
- 프로세스는 운영체제로부터 자원을 할당받은 최소 작업 단위이다.

<img width="696" alt="image" src="https://github.com/yoon-youngjin/spring-study/assets/83503188/4f7ed60f-6e81-45c6-baf6-d0e8aeb095c3">

- 운영체제는 프로세스마다 각각 독립된 메모리 영역(Code/Data/Stack/Heap)의 형식으로 할당해준다.
- 독립된 메모리 영역을 할당해 주기 때문에 프로세스 간 영향을 받지 않고 독립적인 작업을 수행할 수 있다.
  - 서로 간의 접근을 제한하기 때문에 프로세스의 장애에 다른 프로세스가 영향을 받지 않는다.
- 기본적으로 다른 프로세스의 변수나 자료에 접근할 수 없고 IPC나 공유메모리 등의 통신기법들을 사용해서 프로세스 간 통신해야 한다.

<img width="525" alt="image" src="https://github.com/yoon-youngjin/spring-study/assets/83503188/c0c53069-3536-4b13-9e98-9e7fa43b1c27">

### Thread

- 스레드는 프로세스가 운영체제로부터 할당 받은 자원을 이용하는 실행단위 또는 흐름의 단위로서 하나의 프로세스는 반드시 하나 이상의 스레드를 갖는다.
- 프로세스 내에서 각 필요한 Stack만 할당받고 Code, Data, Heap 영역은 공유해서 각 스레드가 공유한다.
- 스레드 간 메모리 스택 영역에 접근 할 수 없으므로 스레드는 독립적인 실행 흐름을 가질 수 있게 되어 독립적인 함수 호출이 가능해진다.
  - 스택 영역은 함수 관련된 데이터를 가지는 영역

<img width="663" alt="image" src="https://github.com/yoon-youngjin/spring-study/assets/83503188/b757a1ca-bbb3-44d3-a8bb-59b44d945364">

### Thread & CPU

- 스레드는 운영체제의 스케줄러에 의해 관리되는 CPU의 최소 실행 단위를 의미한다.
- 스케줄러 알고리즘에 따라 프로세스에 속한 한개의 스레드가 선정디어 CPU에 할당된다.
- 스레드 간 선점이 일어날때 CPU의 실행 흐름(문맥)이 전환되는 컨텍스트 스위칭이 발생

<img width="663" alt="image" src="https://github.com/yoon-youngjin/spring-study/assets/83503188/f29f3c62-ff15-49b6-9151-b229b7ca3000">

## Parallel && Concurrent

### 동시성(Concurrency)

<img width="549" alt="image" src="https://github.com/yoon-youngjin/spring-study/assets/83503188/113731d0-6382-4a9c-8254-89ea2bcdce5d">

- 동시성은 CPU가 한번에 많은 일을 처리하는 것에 중점을 든다. 즉, 많은 작업들을 아주 빠른 시간으로 교체하면서 전체 작업을 처리한다.
  - 하나의 물리장치(코어)가 여러 작업을 번갈아하는것 
- 동시성은 작업의 처리를 빠르게 하기 위한 목적이 아닌 CPU를 효율적으로 사용하는 것에 더 중점을 둔다.
  - 스레드가 작업을 처리하다 IO 블록에 걸렸을 경우 CPU는 다른 스레드로 전환해서 작업을 진행
- 동시성은 작업해야 할 수가 CPU 코어 수 보다 많을 경우 해당되며 동시성이 없으면 작업을 순차적으로 진행해야 한다.

### 병렬성 (Parallel)

<img width="571" alt="image" src="https://github.com/yoon-youngjin/spring-study/assets/83503188/e5f89988-eb12-4886-8f07-53ba6ebb23d0">

- 병렬성은 CPU가 동시에 많은 일을 수행하는 것에 중점을 둔다. 즉 CPU가 놀지 않고 최대한 빠르게 동작
- 병렬성은 런타임에 동시에 물리적으로 작업을 실행하는 것이며 여러 컴퓨팅 리소스가 있는 하드웨어가 필요하다. (한 개의 코어에서는 절대 병렬성이 구현될 수 없다)
- 병렬성은 동시성의 하위 개념으로 작업을 여러 Thread로 분리하고, 윤영체제는 그 Thread를 여러 CPU에 적절히 분배하여 동시적으로 실행되도록 하는 것이다.
- 병렬성은 작업해야 할 수가 CPU 코어 수 보다 같거나 적을 경우 가장 효율성이 좋다.

> 병렬성과 동시성 조합
> 
> ThreadPoolExecutor: 병렬성으로 처리 성능을 극대화하고 동시성으로 CPU 자원을 효율적으로 운영

> Parallelism - Divide and Conquer
> 
> ForkJoinPool: 하나의 태스크를 서브 태스크로 분할하여 병렬처리함으로써 전체 작업 성능을 높인다

## Context Switch

하나의 CPU에서 여러 프로세스를 동시성으로 처리하기 위해서는 한 프로세스에서 다른 프로세스로 전환해야 하는데 이것을 컨텍스트 스위치라고 한다.

### Context

- 프로세스 간 전환을 위해서는 이전에 어디까지 명령을 수행했고, CPU Register에는 어떤 값이 저장되어 있는지에 대한 정보가 필요하다.
- Context는 CPU가 해당 프로세스를 실행하기 위한 프로세스의 정보를 의미하며 이 정보들은 운영체제가 관리하는 PCB라고 하는 커널안의 자료구조에 저장된다.

**PCB(Process Control Block)**

- 운영체제가 시스템 내의 프로세들을 관리하기 위해 프로세스마다 유지하는 정보를 담는 커널 내의 자료구조
- 컨텍스트 스위칭은 CPU가 프로세스 간 PCB 정보를 교체하고 캐시를 비우는 일련의 과정이다.
  - CPU Registry 메모리에는 이전 프로세스에 대한 데이터가 존재하므로 해당 데이터를 비우는 과정이 필요하다.

<img width="556" alt="image" src="https://github.com/yoon-youngjin/spring-study/assets/83503188/c3f68acf-603a-4110-9465-3db428d59b6f">

### 프로세스 상태

- 프로세스는 New, Ready, Running, Waiting, Terminated 상태를 가진다.
  - New: 프로세스를 생성하고 있는 단계로 커널 영역에 PCB가 만들어진 상태
  - Ready: 프로세스가 CPU를 할당받기 위해 기다리고 있는 상태
  - Running: 프로세스가 CPU를 할당받아 명령어를 실행 중인 상태
  - Waiting: 프로세스가 IO 작업 완료 혹은 사건 발생을 기다리는 상태
  - Terminated: 프로세스가 종료된 상태

### Context Switching이 일어나는 조건

- 실행 중인 프로세스에서 IO 호출이 일어나 해당 IO 작업이 끝날때까지 프로세스 상태가 running에서 waiting 상태로 전이된 경우
- Round Robin 스케줄링 등 운영체제의 CPU 스케줄링 알고리즘에 의해 현재 실행 중인 프로세스가 사용할 수 있는 Time Slice을 모두 사용했을 때 해당 프로세스를 중지하고 (ready 상태로 전이) 다른 프로세스를 실행시키는 경우
  - 하드웨어 interrupt

<img width="613" alt="image" src="https://github.com/yoon-youngjin/spring-study/assets/83503188/751c4a6c-5253-4f78-bc2d-0cb43bb16d1b">

<img width="769" alt="image" src="https://github.com/yoon-youngjin/spring-study/assets/83503188/9af4054d-224e-424f-8b5a-efc38cdcd1ba">

- Context Switching이 일어나는 동안 CPU는 일을 하지못하기 때문에 성능에 영향을 준다.

### 스레드 컨텍스트 스위칭

**TCB(Thread Control Block)**

- Thread 상태정보를 저장하는 자료구조이며, PC와 Register Set(CPU 정보), 그리고 PCB를 가리키는 포인터를 가진다.
- 스레드가 하나 생성될 때마다 PCB 내에서 TCB가 생성되며 컨텍스트 스위칭이 일어나면 기존 스레드 TCB를 저장하고 새로운 스레드의 TCB를 가져와 실행한다.

<img width="637" alt="image" src="https://github.com/yoon-youngjin/spring-study/assets/83503188/eb510167-4dab-4ab5-b389-d3481a6c3a0a">

### 프로세스 vs. 스레드

- 프로세스 컨텍스트 스위칭 할 때 메모리 주소 관련 여러가지 처리(CPU 캐시 초기화, TLB 초기화, MMU 주소 체계 수정 등...)를 하기 때문에 오버헤드가 크다.
- 스레드는 프로세스 내 메모리를 공유하기 때문에 메모리 주소 관련 추가적인 작업이 없어 프로세스에 비해 오버헤드가 작아서 컨텍스트 스위칭이 빠르다.
- 스레드는 생성하는 비용이 커서 많은 수의 스레드 생성은 메모리 부족 현상이 발생하거나 빈번한 컨텍스트 스위칭으로 인해 어플리케이션 성능이 저하될 수 있다.

## 사용자 모드 & 커널 모드

- 운영체제는 사용자가 컴퓨터 시스템을 편리하게 사용할 수 있는 환경을 제고앟고 컴퓨터 시스템의 자원을 효율적으로 관리하는 소프트웨어
- 운영체제의 여러 기능 중 핵심 기능을 담당하는 부분을 커널이라고 한다.
- 운영체제는 응용 프로그램이 하드웨어 자원에 직접 접근하는 것을 방지하여 자원을 보호한다
  - 응용 프로그램이 하드웨어 자원에 직접 접근해서 조작 할 수 있다면 자원 관리가 어렵고 프로세스 간 데이터가 훼손되어 컴퓨터 시스템 전체에 오류를 가져올 수 있다.
  - 따라서 응용 프로그램(애플리케이션)이 하드웨어 자원에 접근하려고 할 때 반드시 OS를 통해서만 접근하도록 한다.

<img width="327" alt="image" src="https://github.com/yoon-youngjin/spring-study/assets/83503188/ee351c80-ef8f-4ce0-a90e-3a869bf22e12">

### CPU 권한 모드

- CPU는 명령어를 실행할 때 크게 두 가지 권한 모드로 구분해서 실행하는데 사용자 모드(user mode)와 커널 모드(kernel mode)로 구분한다.
- CPU는 동작하는 동안 두 가지 모드를 번갈아 가면서 수행한다.

<img width="361" alt="image" src="https://github.com/yoon-youngjin/spring-study/assets/83503188/3fbd09a2-0304-4eba-9bc5-6dee5833cd57">

### 사용자 모드(Mode bit = 1)
- 사용자 응용 프로그램의 코드가 실행되는 모드로써 메모리의 유저영역만 접근 가능
- 디스크, 메모리, Printer 및 여러 IO 장치들과 같은 특정 리소스들에 접근할 수 없다.
- 대부분의 응용 프로그램은 입출력 장치나 파일로의 접근이 필요하기 때문에 이때는 유저모드에서 커널모드로의 전환이 되어야 한다.

### 커널 모드(Mode bit = 0)
- 커널 영역의 코드가 실행되는 모드로써 메모리의 유저 영역, 커널 영역 모두 접근 가능
- 하드웨어 자원에 직접 접근 할 수 있다.

**사용자 모드에서 커널 모드로 전환되는 방법?**

### 시스템 호출(System Call)

- 응용 프로그램이 운영체제의 커널이 제공하는 서비스를 이용할 수 있도록 커널모드에 접근하기 위한 인터페이스
- 응용 프로그램이 파일 입출력이나 화면에 메시지를 출력하는 등의 기능은 커널 모드일때 CPU가 실행하기 때문에 반드시 시스템 콜을 통해 커널모드로 전환해야 한다.
- 쓰레드를 생성 및 실행도 커널의 도움을 받아야 한다.

<img width="401" alt="image" src="https://github.com/yoon-youngjin/spring-study/assets/83503188/fd75f1ac-791b-4c88-8420-a3ae6e1319d9">

**시스템 호출 동작 과정**

- 사용자 응용 프로그램은 작업 과정에서 커널의 기능을 사용하기 위해 매우 빈번하게 시스템 콜을 요청하고 이로 인해 사용자 모드와 커널 모드를 상호 전환하며 실행하게 된다.
- IO 처리를 위해 사용자 모드와 커널 모드를 번갈아 오는 것은 컨텍스트 스위칭과 관련이 있으며 이는 멀티 스레드 환경에서 참고해야 할 중요한 배경 지식이다.
  - 커널 모드로 전환된다고 해서 항상 컨텍스트 스위칭이 발생하는 것은 아니다.
  - 자바에서 native 메소드는 시스템 콜을 호출하는 메서드이다.

<img width="796" alt="image" src="https://github.com/yoon-youngjin/spring-study/assets/83503188/933936dc-45a0-4dcb-a4ff-89d213a205d6">

## 사용자 수준 스레드 & 커널 수준 스레드

- 스레드는 크게 두 가지 유형으로 구분하는데 사용자 수준 스레드(User Level Thread)와 커널 수준 스레드(Kernel Level Thread)이다.
- 사용자 수준 스레드는 애플리케이션에서 관리하는 스레드며 커널 수준 스레드는 OS에서 관리하는 스레드이다.

### 사용자 수준 스레드
- 사용자 영역에서 스레드 라이브러리(Pthreads, Windows Threads, Java Threads(JVM))에 의해 스레드의 생성과 종료, 스레드간 메시지 전달, 스레드의 스케줄링 보관 등 모든 것을 관리한다.
- 커널은 사용자 수준 스레드에 대해 알지 못하며 단일 스레드 프로세스인 것처럼 관리한다.
  - 커널에서는 해당 애플리케이션에 대한 프로세스만 관리하고, 마치 단일 스레드처럼 관리된다.

### 커널 수준 스레드
- 커널 수준 스레드란 커널이 스레드와 관련된 모든 작업을 관리한다(PCB와 TCP 관리/유지)
- 커널은 커널 스레드의 모든 정보를 알고 있으며 커널 스레드는 OS 스케줄러에 의해 스케줄링 된다.
- CPU는 커널에 의해 생성된 커널 스레드의 실행만을 담당한다.

### 멀티스레딩 모델

- CPU는 OS 스케줄러가 예약하는 커널 스레드만 할당받아 실행시키기 때문에 사용자 수준 스레드는 커널 수준 스레드와의 매핑이 필요하다.
- 사용자 수준 스레드는 세 가지 모델로 커널 수준 스레드와 매핑하여 구현할 수 있다.
  - 다대일 스레드 매핑, 일대일 스레드 매핑, 다대다 스레드 매핑

**다대일 스레드 매핑**

- 다수의 사용자 수준 스레드가 커널 수준 스레드 한개에 매핑하는 유형으로 사용자 수준의 스레드 모델

<img width="781" alt="image" src="https://github.com/yoon-youngjin/spring-study/assets/83503188/97bcfe0f-4e3e-4da5-88a7-ffbe0f810b59">

- 커널 개입 없이 사용자 슬드끼리의 스위칭이 발생하기 때문에 오버헤드가 작다.
- 스케줄링이나 동기화를 위한 커널을 호출이 일어나지 않으므로 커널 영역으로 전환하는 오버헤드가 적다.
- 개별 스레드 단위가 아닌 단일 스레드의 프로세스 단위로 프로세서를 할당하기 때문에 멀티코어를 활용한 병렬처리를 할 수 없다.
- 한 스레드가 Block IO가 발생하면 모든 스레드들이 Block이 발생하는데 이는 프로세스 자체를 블록하기 때문이다.
- 자바 초기 버전의 Green Thread가 해당 모델

> 실직적으로 실행은 CPU가 하는데 CPU는 커널 수준의 스레드만을 알고있다. 즉, 사용자 수준의 스레드가 실행되기 위해서는 반드시 하나 이상의 커널 수준 스레드와 매핑이 필요하다

**일대일 스레드 매핑**

- 사용자 수준 스레드와 커널 수준 스레드가 일대이롤 매핑하는 유형으로 커널 수준의 스레드 모델

<img width="654" alt="image" src="https://github.com/yoon-youngjin/spring-study/assets/83503188/a66da911-20d3-4592-9e8a-05008728c605">

- 커널이 전체 프로세스와 스레드 정보를 유지해야 하기 때문에 컨텍스트 스위칭 시 사용자 모드에서 커널 모드로 전환해서 스케줄링 하는 등의 오버헤드가 발생
- 자원 한정으로 인해 스레드를 무한정으로 생성할 수 없다. 
  - 대안으로 스레드 풀을 사용
- 스레드 단위로 CPU를 할당하기 때문에 멀티코어를 활용한 병렬처리가 가능
- 스레드 중 하나가 대기 상태가 되더라도 다른 스레드는 실행할 수 있다. 즉, 멀티스레드의 동시성을 활용할 수 있다.
- 자바에서 Native Thread가 해당 모델 -> 현재 상태

**다대다 스레드 매핑**

- 여러 개의 사용자 수준 스레드를 같은 수 또는 그 보다 작은 수의 커널 수준 스레드로 매핑하는 유형
- 각 커널 수준의 스레드가 사용자 수준의 스레드 한개 이상과 매핑된다.
- 해당 모델은 앞선 모델들의 단점을 어느 정도 해결하여, 개발자는 필요한 만큼 많은 사용자 수준 스레드를 생성할 수 있고 커널 수준 스레드가 멀티 프로세서에서 병렬로 수행될 수 있다.
- 사용자 수준 스레드가 IO 시스템 콜을 발생시켰을 때, 커널이 다른 스레드의 수행을 스케줄 할 수 있다.

<img width="600" alt="image" src="https://github.com/yoon-youngjin/spring-study/assets/83503188/4a6f19e9-ce59-4550-9343-f368cfe6e1c2">

